<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Le problÃÂ¨me d'assignement du crÃÂ©dit (avec des ÃÂ©lÃÂ©ments de corrections)</title>
  <link href="https://philippe-preux.github.io/css/ma.css" 
	rel="stylesheet" type="text/css" media="all" />
</head>

<body>

<div class="tpR">

<h1>Le problÃÂ¨me d'assignement du crÃÂ©dit</h1>

<h2>Face ÃÂ  une bande de bandits</h2>

<table>
<td>
Vous allez rÃÂ©aliser une expÃÂ©rience de bandits ÃÂ  4 bras. Pour cela&nbsp;:

<ul>
  <li>lancer R (si vous ne savez plus comment on fait, <a href="../decouverte-R/lancerQuitterR.html">cliquez ici</a>).</li>
  <li>Dans R, tapez la commande <kbd> source ("https://philippe-preux.github.io/ensg/aeac/tps/bandits/4bras.Steyvers-et-al.R")</kbd><br/>(Faites un copier/coller pour ÃÂ©viter les fautes de frappes.)</li>
  <li>L'expÃÂ©rience est lancÃÂ©e&nbsp;; passez-lÃÂ .</li>
</ul>
</td>
<td>
<p align="right">
<img src="bandits.png" width="150" />
</p>
</td>
</table>

<h2>ÃÂtude de vos donnÃÂ©es expÃÂ©rimentales</h2>

<h3>Chargement des donnÃÂ©es et quelques graphiques simples</h3>

<p>

Durant l'expÃÂ©rience, un certain nombre d'informations ont ÃÂ©tÃÂ©
enregistrÃÂ©es ÃÂ  chaque clic. Elles sont dans le fichier
dÃÂ©nommÃÂ© <kbd>4bS.res.xxx.yyy.txt</kbd> oÃÂ¹ <kbd>xxx</kbd>
et <kbd>yyy</kbd> vous identifie ainsi que votre machine. Cette
identification a pour seul but de pouvoir diffÃÂ©rencier les fichiers
les uns des autres.

<br/>
<br/>

Pour les manipulations ci-dessous, celles que nous avons dÃÂ©jÃÂ 
rencontrÃÂ©es ne sont pas expliquÃÂ©es. Si vous avez oubliÃÂ© comment faire,
allez consulter le TP de <a href="../decouverte-R/">dÃÂ©couverte de
R</a>.

</p>

<ul>
  <li>On va charger ce fichier dans R ÃÂ  l'aide de la
    fonction <kbd>read.table()</kbd>. Afin de rendre les manipulations
    qui vont suivre plus simples, on donne un nom aux attributs qui
    correspondent aux colonnes du fichier. Aussi, vous taperez une
    commande du genre&nbsp;:
<pre>> donnees <- read.table ("4bS.res.xxx.yyy.txt", 
     col.names = c ("jeu", "essai", "epoque", "delta.t", "choix", "s", "r", "r.cumule",
                    "p1", "p2", "p3", "p4"))
</pre>
    Bien entendu, vous mettez le nom de fichier correct.
  </li>
  <li>On peut jeter un coup d'&oelig;il aux premiÃÂ¨res donnÃÂ©es en tapant <kbd>head (donnees)</kbd>.
    <br/>
    La premiÃÂ¨re ligne indique le nom des attributs/colonnes et en dessous sont indiquÃÂ©es les 6 premiÃÂ¨res donnÃÂ©es.
    <br/>
    Quand on donne un nom aux attributs, on peut ensuite accÃÂ©der ÃÂ  la valeur d'un attribut soit en spÃÂ©cifiant son numÃÂ©ro de colonne (<i>cf.</i> TP de dÃÂ©couverte), soit en spÃÂ©cifiant son nom&nbsp;:
      <ul>
        <li><kbd>donnees [1, 7]</kbd> et <kbd>donnees$r [1]</kbd> spÃÂ©cifient la mÃÂªme information&nbsp;: la valeur de l'attribut <kbd>r</kbd> de la 1<sup>ÃÂ¨re</sup> donnÃÂ©e. L'attribut <kbd>r</kbd> est en 7<sup>ÃÂ¨</sup> colonne.</li>
      </ul>
    L'ÃÂ©poque indique l'instant du clic&nbsp;: c'est un nombre de secondes. Ce qui compte ici est l'ÃÂ©cart entre deux lignes successives&nbsp;; c'est le temps qui s'est ÃÂ©coulÃÂ© entre deux clics. Ce temps ÃÂ©coulÃÂ© entre un clic et le suivant est dans la colonne 4, attribut dÃÂ©nommÃÂ© <kbd>delta.t</kbd>.
  </li><br/>
  <li>Faites un graphique reprÃÂ©sentant ce temps ÃÂ©coulÃÂ© entre deux clics. Constatez-vous quelque chose&nbsp;?
  </li>
  <li>Il est possible que vous voyiez des points anormaux. Si c'est le cas, analysez-les pour comprendre leur origine.</li>
  <li>Utilisez la fonction <kbd>cor()</kbd> pour calculer la corrÃÂ©lation entre cet intervalle de temps entre deux clics et le retour obtenu. Ces deux attributs sont-ils corrÃÂ©lÃÂ©s (linÃÂ©airement) pour vous&nbsp;?
  </li><br/>
  <li>Faites un graphique de l'attribut <kbd>r.cumule</kbd>. Constatez-vous quelque chose&nbsp;?
  </li>
  <li>Faites un graphique de l'attribut <kbd>r.cumule</kbd> en fonction de l'attribut <kbd>epoque</kbd>. Constatez-vous quelque chose&nbsp;?
  </li>
  <li>Dans ce graphique, faites en sorte que le nombre de secondes depuis le dÃÂ©but de l'expÃÂ©rience soit affichÃÂ© sur l'axe des x. Constatez-vous quelque chose&nbsp;?
  </li>
  <li>Faites un graphique de l'attribut <kbd>r.cumule</kbd> en fonction de l'attribut <kbd>delta.t</kbd>. Constatez-vous quelque chose&nbsp;?
  </li>
  <li>Faites un graphique de l'attribut <kbd>r.cumule</kbd> en fonction de l'attribut <kbd>jeu</kbd>. Constatez-vous quelque chose&nbsp;?
  </li>
</ul>

<h3>SÃÂ©lection d'ÃÂ©lÃÂ©ments dans un data.frame</h3>

<p>

On peut facilement sÃÂ©lectionner des donnÃÂ©es rÃÂ©pondant ÃÂ  un certain critÃÂ¨re. Ainsi&nbsp;:

<ul>
  <li>si l'on veut uniquement les donnÃÂ©es du jeu numÃÂ©ro 4, on tapera la commande <kbd>donnees [donnees$jeu == 4,]</kbd>.</li>
  <li>Si l'on veut les donnÃÂ©es des jeux 4 ÃÂ  7&nbsp;: <kbd>donnees [donnees$jeu %in% (4:7),]</kbd>.</li>
</ul>

<p>

Notez bien la virgule avant le crochet fermant <kbd>,]</kbd> qui
reprend la syntaxe vue la fois prÃÂ©cÃÂ©dente&nbsp <kbd>[ ligne(s),
colonne(s) ]</kbd>.

<br/>

Notez bien ÃÂ©galement l'opÃÂ©rateur <kbd>==</kbd> pour tester l'ÃÂ©galitÃÂ©
entre deux objets. De mÃÂªme, on a <kbd>!=</kbd> pour
diffÃÂ©rent, <kbd>&lt;</kbd>, <kbd>&lt;=</kbd>, <kbd>&gt;</kbd>
et <kbd>&gt;=</kbd>.

</p>

<ul>
  <li>Affichez le nombre de retours cumulÃÂ©s obtenus ÃÂ  l'issue de chaque jeu (autrement dit, ÃÂ  chaque fois que l'attribut <kbd>essai</kbd> est ÃÂ©gal ÃÂ  20).</li>
  <li>Mettez-le dans une variable dÃÂ©nommÃÂ©e <kbd>retours.cumules.finaux</kbd></li>
  <li>Faites-en un <kbd>plot</kbd>. Voyez-vous une tendance&nbsp;?</li>
  <li>Faites-en un histogramme en utilisant la fonction <kbd>hist()</kbd>.</li>
  <li>Pour chaque choix, comptez le nombre de succÃÂ¨s obtenus sur l'ensemble des jeux. L'attribut choix vaut 1, 2, 3 ou 4, selon l'endroit oÃÂ¹ vous avez cliquÃÂ©.</li>
</ul>

<p>

On peut combiner plusieurs conditions. Ainsi, pour sÃÂ©lectionner les
donnÃÂ©es du jeu numÃÂ©ro 2 pour lesquels il y a eu un succÃÂ¨s, on
tapera&nbsp;:

</p>

<pre>> donnees [(donnees$jeu == 2) & (donnees$r == 1),]
</pre>

<p>

L'opÃÂ©rateur <kbd>&</kbd> dÃÂ©note le et-logique. Notez les parenthÃÂ¨ses
autour de chaque condition.

</p>

<ul>
  <li>Pour chaque choix, comptez le nombre de succÃÂ¨s obtenus durant le jeu 1. L'attribut <kbd>choix</kbd> vaut 1, 2, 3 ou 4, selon l'endroit oÃÂ¹ vous avez cliquÃÂ©.</li>
  <li>MÃÂªme question sur le jeu 20.</li>
  <li>MÃÂªme question sur le jeu 1 ÃÂ  5, 6 ÃÂ  10, 11 ÃÂ  15 et 16 ÃÂ  20.</li>
  <li>Durant quel jeu avez-vous obtenu un score (<kbd>r.cumule</kbd>)
    maximum/minium&nbsp;?</li>
  <li>Quel est ce score&nbsp;?</li>
</ul>

<p>

Rappelez-vous qu'existent les fonctions <kbd>min ()</kbd>
et <kbd>max ()</kbd>. Sachez aussi qu'il existe les
fonctions <kbd>which.min ()</kbd> et <kbd>which.max ()</kbD>.
</p>

<h3>RÃÂ©pÃÂ©ter plusieurs fois le mÃÂªme traitement&nbsp;: la boucle</h3>

<h4>Introduction ÃÂ  la notion de boucle</h4>

<p>

Si on veut avoir les dÃÂ©comptes des succÃÂ¨s pour chaque choix pour
chaque jeu, on va devoir taper beaucoup de choses. On peut faire
beaucoup plus simple en utilisant une <i>boucle</i>&nbsp;; pour
commencer, tapez ce qui suit&nbsp;:

</p>

<pre>> for (i in 1:10) {
    print (i)
  }
</pre>

<p>

vous obtenez l'affichage des nombres de 1 ÃÂ  10. Expliquons ce qui
vient de se passer&nbsp;:

</p>

<ul>
  <li><kbd>for (i in 1:10)</kbd> signifie&nbsp;: pour les valeurs de la variable <kbd>i</kbd> variant de 1 ÃÂ  10&nbsp;: c'est-ÃÂ -dire, <kbd>i</kbd> va successivement prendre les valeurs 1, 2, 3, ... jusque 10.</li>
  <li>effectuer pour chacune de ces valeurs les instructions qui se trouvent entre les <kbd>{</kbd> <kbd>}</kbd></li>
  <li>ici, il y a une instruction qui affiche la valeur de <kbd>i</kbd>. On aurait pu effectuer d'autres traitements plus intÃÂ©ressants.
</ul>

<h4>Le nombre de clics sur un choix est-il corrÃÂ©lÃÂ© ÃÂ  la probabilitÃÂ© de succÃÂ¨s associÃÂ©e ÃÂ  ce choix&nbsp;?</h4>

<p>

Avec cette notion de boucle, vous pouvez maintenant afficher le nombre
de clics sur chaque choix ÃÂ  chaque jeu.

<br/>

Pour manipuler aisÃÂ©ment ces dÃÂ©comptes, il faut les placer dans une
matrice. Cette matrice stockera pour chaque jeu et chaque choix le
nombre de clics. Cette matrice a donc 20 lignes (une par jeu) et 4
colonnes (une par choix). Pour crÃÂ©er cette matrice, on tapera&nbsp;:

</p>

<pre>> decomptes.tirages <- matrix (nrow = 20, ncol= 4)
</pre>

<p>

Les ÃÂ©lÃÂ©ments d'une matrice sont accÃÂ©dÃÂ©s comme ceux d'un data.frame,
par la notation <kbd>[ ligne, colonne ]</kbd>.

<br/>

On peut aussi affecter tous les ÃÂ©lÃÂ©ments d'une colonne ÃÂ  la
fois&nbsp;: par exemple, <kbd>decomptes.tirages [2, ] <- c (2, 8, 3,
1)</kbd> affecte tous les ÃÂ©lÃÂ©ments de la 2<sup>ÃÂ¨</sup> ligne de la
matrice.
<!--
pourquoi ce qui suit ne s'affiche-t-il pas ?
-->

<br/>

On veut ÃÂ©tudier la question suivante&nbsp;: a-t-on tendance ÃÂ  cliquer
de plus en plus, voire exclusivement, sur le meilleur choix au fil des
essais d'un jeu&nbsp;? On a envie que la rÃÂ©ponse ÃÂ  cette question soit
plutÃÂ´t positive.

<br/>

Faisons un graphique des dÃÂ©comptes calculÃÂ©s ci-dessus. Cela donne
quelque chose ressemblant ÃÂ  la figure de gauche ci-dessous. Faites
cette figure avant de continuer. 

<br/>

Les fonctions <kbd>which()</kbd> et <kbd>length()</kbd> peuvent ÃÂªtre utiles...

</p>

<img src ="nb.clics.sur.chaque.choix.jpg" />

<img src ="nb.clics.sur.chaque.choix.trie.selon.proba.jpg" />

<p>

<!--
    afficher nombre de renforÃÂ§ateurs sur jeu 3, choix 4
    j <- 13
    c <- 2
    afficher nombre de renforÃÂ§ateurs sur jeu j, choix c
    afficher nombre de renforÃÂ§ateurs sur jeu j, tous les choix
    stocker dans la matrice le nombre de renforÃÂ§ateurs sur jeu j, tous les choix
    stocker dans la matrice le nombre de renforÃÂ§ateurs tous les jeux, tous les choix
 -->

On ne voit pas grand chose sur ce graphique. Le fait qu'ÃÂ  chaque jeu,
la probabilitÃÂ© de succÃÂ¨s de chaque choix change fait que reprÃÂ©senter
le nombre de clics sur chaque choix n'ÃÂ©claire pas la question que nous
nous posons.

<br/>

Pour que la figure soit informative, il faudrait que le choix 1 soit
toujours le plus mauvais, ... le choix 4 toujours le meilleur. Si
l'expÃÂ©rience n'a pas ÃÂ©tÃÂ© menÃÂ©e ainsi pour des raisons ÃÂ©videntes, rien
ne nous empÃÂªche de re-numÃÂ©roter les choix ÃÂ  chaque jeu pour que les
choix soient numÃÂ©rotÃÂ©es de cette maniÃÂ¨re. Comment faire&nbsp;?

<br/>

La fonction <kbd>sort()</kbd> effectue un tri. Par exemple, vous
pouvez taper&nbsp;:

</p>

<pre>> sort (c (.2, .3, .05, .45))
</pre>

<p>

et vous obtenez&nbsp;:

</p>

<pre>[1] 0.05 0.20 0.30 0.45
</pre>

<p>

Vous pouvez aussi taper&nbsp;:
</p>

<pre>> sort (c (.2, .3, .05, .45), index.return = TRUE)
</pre>

<p>

et vous obtenez&nbsp;:

</p>

<pre>$x
[1] 0.05 0.20 0.30 0.45

$ix
[1] 3 1 2 4
</pre>

<p>

Cette notation indique que le rÃÂ©sultat est un objet ayant deux attributs&nbsp;:

</p>

<ul>
  <li>l'attribut <kbd>x</kbd> qui est un vecteur des nombres triÃÂ©s&nbsp;;</li>
  <li>l'attribut <kbd>ix</kbd> qui est un vecteur indiquant l'indice d'origine de chaque nombre, avant le tri&nbsp;: 0,05 ÃÂ©tait en 3<sup>ÃÂ¨</sup> position avant le tri, 0,2 en 1<sup>ÃÂ¨re</sup>, ...</li>
</ul>

<p>

Si vous mettez le rÃÂ©sultat dans un objet comme suit&nbsp;:

</p>

<pre>> resultat.du.tri <- sort (c (.2, .3, .05, .45), index.return = TRUE)
</pre>

<p>

vous pouvez ensuite accÃÂ©der ÃÂ  ces deux informations
par <kbd>resultat.du.tri$x</kbd> et <kbd>resultat.du.tri$ix</kbd>.

<br/>

Supposons maintenant que nous ayons deux objets&nbsp;:

</p>

<ul>
  <li>une liste de valeurs <kbd>valeurs.associees <- c (12, 15, 8, 13)</kbd></li>
  <li>la liste de valeur prÃÂ©cÃÂ©dentes <kbd>valeurs.de.tri <- c (.2, .3, .05, .45))</kbd></li>
</ul>

<p>

On peut imaginer que les secondes sont des probabilitÃÂ©s de succÃÂ¨s sur
chacun des 4 choix et que les premiÃÂ¨res sont les nombres de clics sur
chaque choix. Ainsi, les premiÃÂ¨res sont associÃÂ©es aux secondes&nbsp;:
12 est associÃÂ© ÃÂ  la probabilitÃÂ© 0,2, 15 ÃÂ  la probabilitÃÂ© 0,3, ... Si
on trie les probabilitÃÂ©s par ordre croissant, pour obtenir les
valeurs associÃÂ©s ÃÂ  chaque probabilitÃÂ©, il faut les rÃÂ©-ordonner
ÃÂ©galement. Cela s'obtient comme suit&nbsp;:

</p>

<pre>> resultat.du.tri <- sort (c (.2, .3, .05, .45), index.return = TRUE)
> resultat.du.tri$x
[1] 0.05 0.20 0.30 0.45
> valeurs.associees [resultat.du.tri$ix]
[1]  8 12  15 13
</pre>

<p>

Vous allez maintenant vous inspirer de cela pour rÃÂ©aliser un graphique
comme celui de droite ci-dessus qui reprÃÂ©sente le nombre de clics sur
chaque choix&nbsp;; cette fois-ci, ceux-ci sont renumÃÂ©rotÃÂ©s en
fonction de leur probabilitÃÂ© de succÃÂ¨s (1 = le choix dont la
probabilitÃÂ© de succÃÂ¨s est la plus faible, ... 4 = le choix dont la
probabilitÃÂ© de succÃÂ¨s est la plus forte). Les couleurs sont affectÃÂ©es
comme suit&nbsp;: noir pour le choix 1, rouge pour le choix 2, vert
pour le choix 3, bleu pour le choix 4. Les numÃÂ©ros de ces couleurs
sont 1, 2, 3, 4 respectivement (les choses sont bien faites...).

<br/><br/>

Les probabilitÃÂ©s sont ici stockÃÂ©es dans
le <i>data.frame</i> <kbd>donnees</kbd>, dans les
attributs <kbd>p1</kbd> ÃÂ  <kbd>p4</kbd>, soit les attributs 9 ÃÂ  12.
On peut obtenir ces probabilitÃÂ©s par <kbd>donnees [1, 9:12]</kbd> pour
le 1<sup>er</sup> jeu. Cela est lui-mÃÂªme un <i>data.frame</i>. Si on
veut trier ces valeurs, il faut les mettre dans un vecteur. Cela se
fait ÃÂ  l'aide de la
fonction <kbd>as.numeric</kbd>&nbsp;: <kbd>as.numeric (donnees [i,
9:12])</kbd>.

<!--
<br/><br/>

Pour faire ce qui suit, les attributs que nous n'avons pas encore
dÃÂ©crit sont utiles&nbsp;:

</p>

<ul>
  <li><kbd>p1</kbd> est la probabilitÃÂ© d'obtenir un point si on clique sur le choix 1.</li>
  <li><kbd>p2</kbd> est la probabilitÃÂ© d'obtenir un point si on clique sur le choix 2.</li>
  <li><kbd>p3</kbd> est la probabilitÃÂ© d'obtenir un point si on clique sur le choix 3.</li>
  <li><kbd>p4</kbd> est la probabilitÃÂ© d'obtenir un point si on clique sur le choix 4.</li>
  <li><kbd>s</kbd> est un seuil. C'est un nombre alÃÂ©atoire qui est diffÃÂ©rent ÃÂ  chaque clic. Supposons que l'on ait cliquÃÂ© sur le choix 2, on gagne 1 point si s &lt;= p2.</li>
</ul>
-->
<p>

En prÃÂ©alable ÃÂ  la rÃÂ©alisation du graphique, vous stockerez ces
dÃÂ©comptes dans une matrice dont la colonne i ne contiendra plus le
nombre de clics sur le choix i, mais le nombre de clics sur le choix
dont la probabilitÃÂ© est la i<sup>ÃÂ¨</sup> quand celles-ci sont
ordonnÃÂ©es dans l'ordre croissant. Dans la suite, on nommera cette
matrice <kbd>decomptes.tirages.tries</kbd>.

</p>

<p>

Pour cela, on va partir de la matrice <kbd>decomptes.tirages</kbd> et, pour chaque ligne, on va trier les colonnes en fonciton des probabiltiÃÂ©s de succÃÂ¨s.

<br/>

Si on considÃÂ¨re la 1<sup>iÃÂ¨re</sup> ligne, il faut donc trier <kbd>decomtes.tirages [,1]</kbd> en fonction des probabilitÃÂ©s de succÃÂ¨s. Ces probabilitÃÂ©s de succÃÂ¨s sont constantes durant tout le 1<sup>ier</sup> jeu&nbsp;; on les trouve dans <kbd>donnees [1,9:12]</kbd> par exemple (mais aussi dans <kbd>donnees [2,9:12]</kbd>, <kbd>donnees [3,9:12]</kbd>, ... <kbd>donnees [20,9:12]</kbd>).

<br/>

Il s'agÃÂ®t donc de trier ces probabilitÃÂ©s et d'utiliser leur ordre pour rÃÂ©-ordonner les ÃÂ©lÃÂ©ments de la premiÃÂ¨re ligne de la matrice&nbsp;:

</p>

<pre>tri <- sort (as.numeric (donnees [1, 9:12]), index.return = TRUE)
decomptes.tirages.tries [1, ] <- decomptes.tirages [1, tri$ix]
</pre>

<p>

Pour les 19 lignes suivantes, c'est la mÃÂªme chose&nbsp;; on peut donc mettre cela dans une boucle. 

<br/>

La petite difficultÃÂ© restante est de trouver les probabilitÃÂ©s associÃÂ©es ÃÂ  chaque jeu. Pour le jeu 1, l'une parmi les 20 premiÃÂ¨res lignes de <kbd>donnees</kbd> les contient (<i>cf.</i> ci-dessus). Pour le jeu 2, ces probabilitÃÂ©s sont dans <kbd>donnees [21,9:12]</kbd>, <kbd>donnees [22,9:12]</kbd>, <kbd>donnees [23,9:12]</kbd>, ... <kbd>donnees [40,9:12]</kbd>. Pour le jeu 3, ces probabilitÃÂ©s sont dans <kbd>donnees [41,9:12]</kbd>, <kbd>donnees [42,9:12]</kbd>, <kbd>donnees [43,9:12]</kbd>, ... <kbd>donnees [60,9:12]</kbd>... Pour le jeu 20, ces probabilitÃÂ©s sont dans <kbd>donnees [381,9:12]</kbd>, <kbd>donnees [382,9:12]</kbd>, <kbd>donnees [383,9:12]</kbd>, ... <kbd>donnees [400,9:12]</kbd>.

<br/>

On remarque que pour le jeu <kbd>j</kbd>, ces probabilitÃÂ©s sont dans <kbd>donnees [20 * j,9:12]</kbd>.

</p>

<p>

Quand on met tout cela bout ÃÂ  bout, on obtient ce qui suit&nbsp;:

<pre>decomptes.tirages.tries <- decomptes.tirages
for (j in 1:20) {
  tri <- sort (as.numeric (donnees [j * 20, 9:12]), index.return = T)
  decomptes.tirages.tries [j, ] <- decomptes.tirages.tries [j, tri$ix]
}
</pre>

<!--
<pre>decomptes.tirages.tries <- matrix (nrow = 20, ncol = 4)
for (i in 1:20) {
  for (choix in 1:4) {
    debut <- 20 * (i - 1) + 1
    fin <- debut + 19
    decomptes.tirages.tries [i, choix] <-
      length (which (donnees$choix [debut:fin] == choix))
  }
  tri <- sort (as.numeric (donnees [debut, 9:12]), index.return = T)
  decomptes.tirages.tries [i, ] <- decomptes.tirages.tries [i, tri$ix]
}
-->

ÃÂ l'issue de l'exÃÂ©cution de cette boucle, la variable <kbd>decomptes.tirages.tries</kbd> contient les valeurs attendues dans les diffÃÂ©rentes colonnes&nbsp;: la colonne 1 correspond au choix dont la probabilitÃÂ© de succÃÂ¨s est la plus faible, ainsi de suite jusque la colonne 4 qui contient le nombre de clics sur le choix ayant la plus grande probabilitÃÂ© de succÃÂ¨s.

</p>

<ul>
  <li>Une fois le graphique rÃÂ©alisÃÂ©, constatez-vous quelque chose&nbsp;?</li>
  <li>Y a-t-il un lien entre le nombre de clics sur le i<sup>ÃÂ¨</sup> choix triÃÂ© et i&nbsp;? Vous pouvez calculer la proportion de clics sur chacun des choix pendant chacun des jeux. Conclusion&nbsp;?</li>
<!--
    C'est encore mieux de calculer cette proportion au fil d'un jeu, avec une fenÃÂªtre glissante.
 -->
</ul>

<h4>Autres activitÃÂ©s avec des boucles</h4>

<ul>
  <li>Mettez dans une matrice le nombre de succÃÂ¨s
    obtenus ÃÂ  chaque jeu pour chaque choix&nbsp;;</li>
  <li>pour chaque jeu, dÃÂ©terminez le choix ayant obtenu le plus grand
    nombre de succÃÂ¨s.</li>
</ul>

<ul>
  <li>Produire un graphique comme celui-ci&nbsp;:
    <br/>
    <img src="r.cumule.jpg" 
	 alt="r cumulÃÂ© au fil des essais, pour les diffÃÂ©rents jeux."/>
    <br/>
    qui reprÃÂ©sente l'attribut <kbd>r.cumulÃÂ©</kbd> au fil des essais et des jeux.
</ul>

<h3>ÃÂtude des comportements ÃÂ©mis</h3>

<p>

On pose quelques questions plus ouvertes pour analyser le comportement
que vous avez ÃÂ©mis. Pour y rÃÂ©pondre, il faut rÃÂ©flÃÂªchir ÃÂ  une mÃÂ©thode
et la mettre en &oelig;uvre.

</p>

<h4>Scores maximal et moyen</h4>

<ul>
  <li>Quel est le score maximal moyen que l'on peut obtenir ÃÂ  chaque jeu&nbsp;? (prÃÂ©cision&nbsp;: c'est le score maximal <i>moyen</i>, c'est-ÃÂ -dire&nbsp;: imaginons que l'on rÃÂ©pÃÂ¨te plusieurs fois un mÃÂªme jeu, donc avec un mÃÂªme ensemble de probabilitÃÂ©s de succÃÂ¨s associÃÂ© aux 4 choix. Le score maximal moyen est la moyenne des retours cumulÃÂ©s obtenus lors de cette rÃÂ©pÃÂ©tition.</li>
  <li>ÃÂ chaque jeu, quel est le score moyen si on a un comportement 
    alÃÂ©atoire (choix uniforme)&nbsp;?</li>
  <li>OÃÂ¹ se situent vos scores&nbsp;?</li>
  <li>Faites le graphique suivant (qui reprend le prÃÂ©cÃÂ©dent et le
    complÃÂ¨te)&nbsp;:<br/>
    <img src="r.cumule+esperance.jpg" 
	 alt="r cumulÃÂ© avec espÃÂ©rance."/>
    <br/>
    Sur ce graphique, pour chaque jeu, on indique la performance moyenne 
    espÃÂ©rÃÂ©e si on fait les choix selon un tirage alÃÂ©atoire uniforme.
<!--, ainsi 
    qu'un ÃÂ©cart-type de part et d'autre de cette espÃÂ©rance (la variance 
    est ÃÂ©gale ÃÂ  1/12).
-->
</li>
  <!--li>Y a-t-il une corrÃÂ©lation (linÃÂ©aire) entre l'espÃÂ©rance de retour 
    cumulÃÂ© durant un jeu et le retour cumulÃÂ© que vous avez obtenu&nbsp;?</li-->
</ul>

<h4>Relation entre nombre de clics et probabilitÃÂ© de succÃÂ¨s</h4>

<p>

A-t-on cliquÃÂ© plus souvent sur les choix dont la probabilitÃÂ© de succÃÂ¨s est ÃÂ©levÃÂ©e&nbsp;? 

<br/>

Pour le savoir, faire un graphique indiquant en abscisses la probabilitÃÂ© des choix et en ordonnÃÂ©es, le nombre de clics sur ce choix. On obtiendra un graphique dans ce genre-lÃÂ &nbsp;:

</p>

<img src="prop-clics.vs.proba.succes.png" width="500" />


<h4>VariabilitÃÂ© du comportement intra-jeu</h4>

<p>

On se demande si le comportement est plus variÃÂ© au dÃÂ©but d'un jeu qu'ÃÂ 
la fin. Cette variabilitÃÂ© est-elle plus faible ÃÂ  la fin d'un
jeu&nbsp;? ...

</p>

<ul>
  <li>Comment ÃÂ©tudiez-vous cette question&nbsp;?
  <li>Quelle est votre conclusion concernant votre comportement&nbsp;?</li>
</ul>


<!-- Start of StatCounter Code -->
<script type="text/javascript" language="javascript">
var sc_project=2030719; 
var sc_invisible=1; 
var sc_partition=18; 
var sc_security="2ee406dd"; 
</script>

<script type="text/javascript" language="javascript" src="http://www.statcounter.com/counter/counter.js"></script><noscript><a href="http://www.statcounter.com/" target="_blank"><img  src="http://c19.statcounter.com/counter.php?sc_project=2030719&java=0&security=2ee406dd&invisible=0" alt="" border="0"></a> </noscript>
<!-- End of StatCounter Code -->

</div>
</body>
</html>
