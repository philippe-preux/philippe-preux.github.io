<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Processus aléatoires, statistiques et reproductibilité expérimentale</title>
  <!--link href="/home/ppreux/philippe-preux.github.io/css/ma.css" -->
  <link href="https://philippe-preux.github.io/css/ma.css" 
	rel="stylesheet" type="text/css" media="all" />
  <link rel="shortcut icon" type="image/x-icon" 
	href="https://philippe-preux.github.io/img/site.ico" />
	<!-- href="/home/ppreux/philippe-preux.github.io/img/site.ico" /-->
  <style type="text/css">
    div.c {
	background-color: #bafcba;
    }
    div.python {
	background-color: #c0c0c0;
    }
  </style>
</head>

<body>
<div class="tpR">

  <h1>Processus aléatoires, statistiques et reproductibilité expérimentale</h1>

  <p>

    Ce TP a pour objet de présenter un certain nombre de points liés à la maîtrise de la notion d'aléa dans les expériences informatiques.

    <br/>

    Dans les UEs de PDI et APR, nous étudions des algorithmes stochastiques, c'est-à-dire qu'<i>a priori</i>, ils donnent des résultats différents à chacune de leur exécution. Pour étudier le comportement de ces algorithmes, il faut tenir compte de cette variabilité et utiliser les outils adéquats pour cela. Outre la variabilité des résultats, un concept scientifique clé est la capacité à reproduire les résultats d'une expérience. L'objet de ce TP est d'étudier ces notions et d'indiquer comment les prendre en compte concrétement.

    <br/>
    <br/>

    Ce TP s'inspire fortement d'un TP réalisé ces dernières années en PDI qui est disponible <a href="https://fabienpesquerel.github.io/blog/2022/random-number-generation-101/">là</a>. Celui-ci est exprimé en utilisant le langage Python. Le TP présenté ici est réalisé en C ou en python, au choix, pour différentes raisons&nbsp;: 1) contrairement à ce que l'on peut croire, on n'est pas obligé de travailler en Python quand on travaille en apprentissage automatique et ce TP le démontre&nbsp;; 2) ce TP peut aussi très facilement être réalisé en R par exemple, ou C++ ou bien d'autres langages. <!--Et si vous préférez le faire en C++ ou R, allez-y&nbsp;! --> Je rappelle que <a href="https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf">le langage C est le langage le plus vert</a>, le moins consommateur en ressources, le moins pollueur (50x moins que python par exemple).

  </p>

  <h2>Génération de nombres pseudo-aléatoires</h2>

  <h3>Pré-requis</h3>

  <table>
    <tr>C</tr><tr>python</tr>
    <tr><td bgcolor="#c0c0c0" width="50%" >
	<div class="c">
	  On utilise la bibliothèque <kbd>gsl</kbd> (GNU Scientific Library) qui contient de multiples fonctions mathématiques. Elle est installée sur les ordinateurs en salle TP. Sur votre ordinateur personnel, il faut peut-être l'installer.

	  <br/>

	  On utilisera le compilateur <kbd>gcc</kbd> et on spécifiera les options <kbd>-lgsl -lgslcblas -lm</kbd> pour éditer les liens avec les bibliothèques nécessaires.
	</div>
      </td>
      <td bgcolor="#c0c0c0" width="50%" >
	<div class="python">
	  On utilise la bibliothèque <kbd>numpy</kbd> qui doit donc être installée.
	  </div>
      </td>
    </tr>
  </table>

  <h3>Génération de nombres pseudo-aléatoires</h3>
  
  <h4>Activité 1</h4>
  
  <p>
    
    La notion de nombres (pseudo-)aléatoires est une notion complexe. La génération d'une séquence de nombres aléatoires par un algoithme est un problème aussi vieux que l'apparition des premiers ordinateurs&nbsp;; des progrès ont été faits et ils se poursuivent. La fonction de base consiste à générer un entier naturel dont la valeur est comprise entre 0 et 2<sup>N</sup>-1 où N est le nombre de bits composant les mots manipulés par le(s) microprocesseur(s) pendant un calcul. À chaque appel, cette fonction de base renvoit un nombre différent. On veut que cette séquence de nombres respectent certaines propriétés (par exemple, une distribution uniforme dans l'intervalle de valeurs, ou encore la non répétition de séquences) quel que soit le nombre d'appels à cette fonction, donc quelle que soit la longueur de la séquence de nombres pseudo-aléatoires générés. L'infini n'étant pas atteignable dans un programme d'ordinateur, on veut que ces propriétés soient respectées par des séquences aussi longues que possibles.

    <br/>
    <br/>

    <b>Question&nbsp;:</b> combien de séquences d'entiers différentes sont possibles avec un ordinateur travaillant sur N bits à la fois&nbsp;?

    <br/>
    <br/>

    Remarque&nbsp;: vous avez noté l'utilisation du mot «&nbsp;pseudo&nbsp;» avant le mot aléatoire. On veut ainsi distinguer un nombre aléatoire au sens mathématique du terme d'un nombre calculé par un algorithme pour donner l'impression que la séquence de nombres est aléatoire. Curieusement, l'algorithme qui calcule une telle séquence est <b>déterministe</b>&nbsp;: la séquence est construite à l'aide d'une (simple) équation de récurrence. Le premier terme (ou les premiers termes) de cette séquence est fourni par l'utilisateur et se nomme la <i>graine</i>.

    <br/>

    Quand on exécute un programme utilisant un générateur de nombres pseudo-aléatoires, il faut <b>impérativement</b> sauvegarder la valeur de la graine. C'est le seul moyen de ré-exécuter exactement de la même manière un programme. C'est une faute de ne pas sauvegarder cette valeur.
    
    <br/>
    <br/>

    Remarque&nbsp;: nous n'abordons pas ce point dans le cadre de ce TP ni de ce cours, mais la génération de nombres pseudo-aléatoires par un programme distribué ou simplement mutli-threadé complique les choses&nbsp;: les différentes séquences de nombres doivent êtres différentes mais elles doivent respecter des propriétés globales. 
    
    <br/>

    Autre remarque&nbsp;: d'un point de vue scientifique, on ne sait pas si l'aléatoire existe. Toute la physique, donc l'explication du monde, est déterministe jusqu'à la découverte de la physique quantique au début du XX<sup>è</sup> siècle. Celle-ci semble s'appuyer sur des processus intrinséquement aléatoires, mais c'est peut-être juste que nous l'avons pas encore bien comprise. La physique quantique a profondément perturbé les physiciens et plus généralement les scientifiques dans leur appréhension du monde.

    <br/>
    <br/>

    À partir d'un générateur d'entiers pseudo-aléatoires compris entre 0 et <kbd>MAX_INT</kbd>, on obtient facilement un nombre «&nbsp;réel&nbsp;» (flottant) compris dans [0, 1[ en divisant cet entier par <kbd>MAX_INT</kbd>. Comme il est très courant d'avoir besoin de générer des nombres dans cet intervalle, il y a généralement une fonction qui le fait directement, c'est-à-dire qui renvoit un nombre pseudo-aléatoire dans l'intervalle [0, 1[. 
    
  </p>
  
  <table>
    <th>C</th><th>python</th>
    <tr><td bgcolor="#bafcba" width="50%" >
	<p>
	  En C, on utilise typiquement une fonction qui génère un entier naturel pseudo-aléatoire compris entre 0 et <kbd>MAX_INT</kbd>. On obtient facilement un nombre flottant dans [0, 1[ en divisant cet entier par <kbd>MAX_INT</kbd>.

	  <br/>

	  On peut utiliser la fonction <kbd>random()</kbd> de la <kbd>libc</kbd> mais pour la suite du TP, il est avantageux d'utiliser la bibliothèque <kbd>gsl</kbd>. Cela va donner quelque chose comme cela&nbsp;

	</p>

	<ul>
	  <li>En début de programme, on inclut le fichier <kbd>gsl/gsl_rng.h</kbd>.</li>
	  <li>On définit une variable et on alloue une variable qui permettra de générer les nombres pseudo-aléatoires&nbsp;:
<pre>static gsl_rng *prng = NULL;
prng = gsl_rng_alloc (gsl_rng_mt19937);</pre>
	  <li>Et quand on veut générer un nombre pseudo-aléatoire, on fait simplement&nbsp;:
	    <ul>
	      <li>Pour un entier&nbsp;: <kbd>gsl_rng_get (prng)</kbd>.</li>
	      <li>Pour un flottant dans [0, 1[&nbsp;: <kbd>gsl_rng_uniform (prng)</kbd>.</li>
	    </ul>
	  </ul>
	<p>
	  Il existe de nombreuses manières de générer une séquence de nombres pseudo-aléatoires. Ici on utilise le <i>Mersenne Twister</i> en spécifiant <kbd>mt19937</kbd>. Cet algorithme est connu pour avoir de bonnes propriétés.
	</p>
      </td>
      <td bgcolor="#c0c0c0" width="50%" >
	<p>
	  En python, on utilise typiquement une fonction de la bibliothèque <kbd>numpy</kbd> qui renvoie un nombre flottant dans l'intervalle [0, 1[.
	</p>
<pre>import numpy as np
np.random.rand (1)</pre>
	<p>
          affiche un nombre pseudo-aléatoire compris entre 0 et 1 (0 inclus, 1 exclus).
	</p>
	<p>
	  En procédant ainsi, on utilise un algorithme qui se nomme PCG64 qui est plus récent que le Mersenne Twister et génère de meilleures séquences de nombres pseudo-aléatoires.
      </td>
    </tr>
  </table>

  <p>

    <b>Question 1&nbsp;:</b> écrire un programme qui affiche une suite de 10 nombres pseudo-aléatoires compris dans [0, 1[.
    
  </p>

  <h4>Activité 2</h4>
  
  <p>

    Exécutez plusieurs fois le programme précédent et comparez les résultats&nbsp;: qu'observez-vous&nbsp;?

    <br/>

    En science, quand on effectue une expérience, il y a un principe fondamentale qui est celui de la reproductibilité&nbsp;: si je fais plusieurs fois la même expérience dans les mêmes conditions, le résultat doit toujours être le même.

    <br/>

    En informatique, dans certaines conditions, exécuter un programme est analogue à la réalisation d'une expérience. En appliquant le principe fondamental ci-dessus, on veut qu'exécuter un même programme plusieurs fois donne le même résultat. Et si on veut que programme donne des résultats différents à chaque exécution, on veut que cette variabilité soit contrôlée, c'est-à-dire qu'elle soit elle-même reproductible&nbsp;: on veut que l'aléatoire ce ne soit pas n'importe quoi, mais un aléatoire reproductible.

    <br/>

    La solution à ce problème est très simple. Elle consiste à initialiser la série de nombres pseudo-aléatoires avec un certain nombre qui se nomme une graine. Si on fournit une certaine graine à un certain générateur de nombres pseudo-aléatoires, il génère ensuite toujours la même séquence de nombres. Dans les exemples ci-dessous, on utilise la graine 123456. Utilisez celle que vous voulez.
    
  </p>

  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  En C, à la suite de ce qui a été expliqué plus haut, on fixe la graine par un appel à la fonction <kbd>gsl_rng_set (prng, 123456)</kbd>.
	  <br/>
	  Ensuite, la séquence de nombres qui sera générée lors des appels successifs aux fonctions vues plus haut sera toujours la même pour une graine donnée.
	</p>
      </td>
      <td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, on crée un générateur de nombres pseudo-aléatoires par <kbd>prng = np.random.default_rng (123456)</kbd>.
	  <br/>
	  Ensuite, on génère des nombres via cet objet&nbsp;: <kbd>prng.random(1)</kbd> où 1 indique la quantité de nombres pseudo-aléatoires à générer.
	</p>
      </td>
    </tr>
  </table>
  
  <p>

    <b>Question 2&nbsp;:</b> modifier votre programme en initialisant correctement la graine. Exécutez le plusieurs fois. Que constatez-vous&nbsp;?

    <br/>
    
    <b>Question 2bis&nbsp;:</b> comparer la séquence de nombres (une dizaine) par votre programme avec la graine n, n+1 et n-1. Que constatez-vous&nbsp;? Connaissez-vous un moyen de comparer ces séquences de nombres&nbsp;?
    
  </p>

  <h4>Activité 3</h4>
  
  <p>

    
    
  </p>

  <h4>Activité 4</h4>
  
  <p>

    
    
  </p>

  <h4>Activité 5</h4>
  
  <p>

    Les nombres générés précédemment sont uniformément répartis dans l'intervalle [0, 1[. On va le vérifier en réalisant un histogramme.

    <br/>
    
    <b>Question 5&nbsp;:</b> générer 10.000 nombres pseudo-aléatoires compris dans [0, 1[ et en faire un histogramme.

  </p>
  
  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  En C, on va utiliser la bibliothèque PLplot qui permet de réaliser des graphiques. Le but de ce TP n'étant pas d'apprendre à utiliser PLplot, je mets à votre disposition deux fichiers que vous allez utilisez&nbsp;: <a href="./barplot.h"><kbd>barplot.h</kbd></a> et <a href="./barplot.c"><kbd>barplot.c</kbd></a>. Il faut inclure le premier dans votre programme et compiler votre programme avec le second. J'y ai défini quelques fonctions qui vont créer très facilement les graphiques nécessaires dans ce TP.
	  <br/>
	  <br/>
	  PLplot est installé sur les machines de la salle de TP. Pour compiler, il faut ajouter les arguments <kbd>-I./barplot.h -I/usr/include/plplot -lplplot</kbd> à la ligne de commande <kbd>gcc</kbd>.
	  <br/>
	  <br/>
	  Il faut construire un histogramme des 10000 nombres et ensuite appeler la fonction <kbd>barplot()</kbd> fournie dans le fichier <kbd>barplot.c</kbd>. Cette fonction prend 4 paramètres&nbsp;:
	  <ul>
	    <li>un tableau de <kbd>n</kbd> <kbd>double</kbd>s qui sont les décomptes de valeurs tombant dans chacune des <i>n</i> cellules de l'histogramme&nbsp;;</li>
	    <li>un tableau de <kbd>n+1</kbd> <kbd>double</kbd>s qui sont les bords de chacune des <i>n</i> cellules de l'histogramme&nbsp;;</li>
	    <li>le nombre <kbd>n</kbd> lui-même&nbsp;;</li>
	    <li>un titre à donner à la figure.</li>
	  </ul>
	  Vous pouvez écrire une fonction qui calcule l'histogramme vous-même ou utiliser les fonctions de la GSL qui calculent un histogramme.
	  Puis&nbsp;:
	  </p>
	  <pre>barplot (les_valeurs, les_bords, n, titre)</pre>
	  <p>
	  Et on obtient&nbsp;:
	  <br/>
	  <img src="q5.png" width="500pt" />
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, en plus de ce que l'on a vu pour générer des nombres pseudo-aléatoires, on va obtenir l'histogramme en utilisant la fonction <kbd>hist()</kbd> de la bibliothèque matplotlib. Ainsi, vous obtiendrez&nbsp;:
	  <br/>
	  <img src="q5fPCG64.png" width="500pt" />
	  <!--img src="https://fabienpesquerel.github.io/assets/img/posts/2022-10-16-random-number-generation-101/rng_post_answer5_1-1400.webp" width="500pt" /-->
	</p>
      </td>
    </tr>
  </table>

  <p>
    <b>Question 5bis&nbsp;:</b> comparer visuellement ces histogrammes&nbsp;; qu'en pensez-vous&nbsp;?
    <br/>
    <b>Question 5ter&nbsp;:</b> générer les histogrammes pour les graines n, n+1 et n-1. Que constatez-vous&nbsp;?
  </p>

  <h4>Activité 6</h4>
  
  <p>

    Il est courant de vouloir générer des nombres pseudo-aléatoires dont la distribution n'est pas uniforme. Il existe en effet des tas de distributions de probabilité. On distingue les distributions discrètes des distributions continues. Par exemple, si on veut simuler le lancer d'un dé à 6 faces, on génère un nombre dans l'ensemble { 1, 2, 3, 4, 5, 6 }&nbsp;; si on veut simuler le lancer d'une pièce (pile ou face), on génère 0 ou 1, de manière équi-probable si la pièce est équilibrée, ou avec une probabilité <i>p</i> pour l'un et 1-<i>p</i> pour l'autre si la pièce est déséquilibrée. Dans le premier cas, c'est une distribution uniforme discrète&nbsp;; dans le troisième, c'est une loi de Bernoulli de paramètre <i>p</i>&nbsp;; le deuxième cas peut être vu soit comme une loi uniforme, soit comme une loi de Bernoulli avec <i>p</i>=1/2.

    <br/>
    <br/>

    Pour de très nombreuses lois de distribution de probabilités, il existe une fonction qui génère des nombres pseudo-aléatoires suivant cette loi. L'une des plus classiques est la loi normale (ou gaussienne, ou «&nbsp;en cloche&nbsp;».

    <br/>
    <br/>
    
    <b>Question 6&nbsp;:</b> générer 10.000 nombres pseudo-aléatoires distribués normalement (moyenne nulle, écart-type 1) et en faire un histogramme.

  </p>

  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  Avec la GSL, on génère un nombre pseudo-aléatoire selon une loi nrmale de moyenne nulle et d'écart-type <i>s</i> à l'aide de la fonction <kbd>gsl_ran_gaussian (prng, s)</kbd>. Pour accéder à cette fonction, il faut include le fichier <kbd>gsl/gsl_randist.h</kbd>.
	  <br/>
	  On obtient&nbsp;:
	  <br/>
	  <img src="q6.png" width="500pt" />
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, on génère <i>n</i> nombres pseudo-aléatoires selon une loi nrmale de moyenne <i>m</i> et d'écart-type <i>s</i> à l'aide de la fonction <kbd>rng.normal (loc = m, scale = s, size = n)</kbd>.
	  <br/>
	  On obtient&nbsp;:
	  <br/>
	  <img src="q6fPCG64.png" width="500pt" />
	</p>
      </td>
    </tr>
  </table>

  <h4>Activité 7</h4>
  
  <p>

    On va maintenant écrire notre propre générateur de nombres pseudo-aléatoires. Même s'il n'aura pas les bonnes propriétés des générateurs vus précédemment, il aura l'avantage d'être simple et de montrer comment on peut générer des nombres pseudo-aléatoires avec un algorithme déterministe.

    <br/>
    <br/>

    Ce générateur engendre des nombres compris dans ]0, 1[. Il s'appuie sur une équation de récurrence très simple&nbsp;: x<sub>n+1</sub> &leftarrow; m&nbsp;x<sub>n</sub> + c [q].

    <br/>

    Dans cette équation, m, c et q sont des paramètres entiers.
    La notation [q] signifie «&nbsp;reste de la division du terme de gauche par q&nbsp;».
    Si a un moment x<inf>n</inf> est nul, il faut le remplacer par c.
    La graine correspond à la valeur de x<sub>0</sub>.
    
    <br/>
    <br/>
    
    <b>Question 7&nbsp;:</b> implanter ce générateur de nombres pseudo-aléatoires en prenant m = 1103515245, c = 12345 et q = 2<sup>31</sup>. Générer 10.000 nombres et en faire un histogramme. Le résultat correspond-il à vos attentes&nbsp;?

    <br/>

    J'obtiens cet histogramme&nbsp;:

    <br/>
    
    <img src="./q7.m1103515245.png" width="500pt" />
    
    <br/>
    <br/>
    
    <b>Question 7bis&nbsp;:</b> prendre c = 1 et m = 127, générer 10.000 nombres et faites un histogramme. Ensuite, prendre c = 1 et m = 128, générer 10.000 nombres et faites un histogramme. Le résultat correspond-il toujours à vos attentes&nbsp;?
    
    <!--
	<img src="q7.m128.png" width="500pt" />
	<img src="q7.m127.png" width="500pt" />
    -->
	
  </p>

  <h4>Activité 8</h4>
  
  <p>

    <b>Question 8&nbsp;:</b> générer 5000 points dans le carré unité. Pour cela, vous générez 10000 nombres pseudo-aléatoires entre 0 et 1 et chaque paire correspond aux coordonnées d'un point. Faites-en un graphique.

  </p>
  
  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  Pour la partie graphique, <kbd>barplot.c</kbd> contient la fonction scatter_plot ()</kbd> qui prend 3 arguments&nbsp;: un tableau de paires de <kbd>double</kbd>s, un entier qui est le nombre de paires et une chaîne de caractères qui sera le titre du graphique.
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  On utilise la fonction <kbd>scatter</kbd> de maplotlib.
	</p>
      </td>
    </tr>
  </table>

      <p>

	J'obtiens une figure comme celle-ci&nbsp;:

	<br/>
	
	<img src="5000pseudo-points.png" width="500pt" />

	<br/>

	On constate qu'il y a des vides.
	
      </p>
	
  <h4>Activités libres</h4>

      <p>

	On indique ici des activités supplémentaires. Vous êtes vivement encouragés à les réaliser.
	
      </p>

      <ul>
	<li>En python, pour générer des nombres pseudo-aléatoire avec le Mersenne Twister, il faut utiliser&nbsp;:
	  <br/>
	  <pre>from numpy.random import RandomState
gnpa = RandomState (seed)</pre>
	  à la place de ce qui a été indiqué plus haut (qui utilise PCG64).
	  <br/>
	  Écrivez les mêmes programmes en C et en python qui chacun génére 10000 nombres pseudo-aléatoires avec le Mersenne Twister. Faites les histogrammes, comparez. Qu'en pensez-vous&nbsp;?</li>
	<li>De même, générer seulement 10 nombres pseudo-aléatoires avec le Mersenne Twister en C et en python. Affichez-les et comparez-les. Que consatez-vous&nbsp;?</li>
	<li>Python utilise un générateur dénommé PCG64. Celui-ci n'est pas disponible dans la GSL mais son <a href="https://www.pcg-random.org/using-pcg-c.html">code est disponible sur Internet</a>. Écrire un programme en C qui utilise ce générateur et faites les mêmes comparaisons que ci-dessus avec le Mersenne Twister.</li>
	<li>Et pour finir, un peu de lecture&nbsp;:
	  <ul>
	    <li>test pour évaluer les qualités d'un générateur de nombres pseudo-aléatoires&nbsp;: <a href="https://webhome.phy.duke.edu/~rgb/General/dieharder.php">dieharder</a>.</li>
	    <li>pour en savoir plus sur les nombres pseudo-aléatoires et leur génération&nbsp;: <a href="http://www.iro.umontreal.ca/~lecuyer/myftp/papers/handsim.ps">Random Number Generation</a> de L'Ecuyer&nbsp;; 2è volume de <i>The Art of Computing, Seminumerical Algorithms</i> de D. Knuth&nbsp;; le chapitre 7 des <i>Numerical recipes in C</i>.
	</ul></li>
      </ul>
      
  <h2>Quelques notions essentielles de statistiques</h2>

	<p>

	  Face à un processus qui donne des résultats différents, on essaie de résumer ceux-ci sous une forme facile à appréhender et qui caractérise le processus. C'est l'objectif des histogrammes faits précédemment. Plus généralement, un graphique peut décrire de manière simple une séquence de nombres. Il existe des tas de types de graphiques qui permettent de représenter telle ou telle propriété,. D'une manière générale, c'est un domaine de recherche complet qui entend rendre intelligible de manière graphique un ensemble de données, la <i>visualisation de données</i>.

	  <br/>
	  <br/>

	  Il y a d'autres manières de réaliser un résumé de manière quantitative, issues des statistiques descriptives. La plus connue est la moyenne.

	<p/>

	<h4>Activité 9</h4>
	
	<p>

	  Il est important de connaître la «&nbsp;manière statistique&nbsp;» d'envisager la situation. Celle-ci suppose qu'il existe un processus qui engendre des données (dans ce TP, c'est un algorithme de génération de nombres pseudo-aléatoires), processus dont les propriétés existent mais sont inconnues. Par exemple, on suppose que les nombres générés par ce generateur ont une certaine moyenne, mais on ne la connait pas. Cette moyenne inconnue est nommée la <i>vraie</i> moyenne. Dès lors, on va essayer de la déterminer&nbsp; en statistiques, on dit qu'on l'estime.

	  <br/>
	  <br/>

	  <b>Question 9&nbsp;:</b> d'après vous, quelle est la valeur moyenne des nombres générer de manière uniforme dans l'intervalle [0, 1[&nbsp;? Même question si les nombres sont générés dans [0, 1] ou dans ]0, 1[ ou dans ]0, 1].
	    
	  <br/>
	  <br/>
	  
	  Faites l'expérience suivante&nbsp;: écrire un programme qui engendre 10 nombres pseudo-aléatoires uniformément répartis entre 0 et 1 (comme vu plus haut) et qui affiche la moyenne des i premiers nombres, pour i de 1 à 10.

	</p>
	
  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  En C, j'obtiens&nbsp;:
	  <br/>
	  <pre>0.12697
0.3209415
0.5362003
0.6266815
0.5534404
0.578837
0.6243227
0.6436361
0.6139821
0.6457462</pre>
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, j'obtiens&nbsp;:
	  <br/>
	  <pre>0.6365137498589308
0.5106627073737531
0.35625694539149694
0.5060058939475681
0.5860149024786793
0.5645073445412173
0.5239396490587402
0.5379657933633322
0.5871596707079398
0.6096868822693744</pre>
	</p>
      </td>
    </tr>
  </table>
  
	<p>
	  
	  Qu'en pensez-vous&nbsp;?

	  <br/>
	  <br/>

	  Refaire le même genre de chose mais cette fois-ci, générer 10<sup>6</sup> nombres pseudo-aléatoires et afficher leur moyenne toutes les 10<sup>5</sup> itérations (la moyenne de tous les nombres qui ont été générés jusqu'à cette itération).
	  
	</p>
	
	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		En C, j'obtiens&nbsp;:
		<br/>
		<pre>0.502091
0.50168
0.500681
0.500621
0.500484
0.500331
0.500313
0.500292
0.500307
0.50028</pre>
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, j'obtiens&nbsp;:
	  <br/>
	  <pre>0.49998361543953534
0.5005033518601376
0.5005979192226971
0.5004579771726371
0.5004691791699108
0.5005069039996045
0.5003719607781464
0.5002382648383843
0.5002204247517089
0.500302828901582</pre>
	</p>
      </td>
    </tr>
  </table>
  
	<p>
	  
	  Qu'en pensez-vous&nbsp;? Qu'est-ce qui change&nbsp;? Pourquoi&nbsp;?

	</p>

	<p>
	    
	  <b>Vocabulaire</b>&nbsp;:

	  <br/>
	  
	  jusqu'à maintenant, on a utilisé le vocabulaire de l'informatique pour parler de la génération de nombres pseudo-aléatoires. Quand on se met à réflêchir sous l'angle des statistiques et d'un processus qui génère des données, on a l'habitude le vocabulaire des statistiques. Les termes sont synonymes&nbsp;:

	  <br/>

	  au lieu de «&nbsp;générer un nombre pseudo-aléatoire&nbsp;» on dit qu'on «&nbsp;échantillonne&nbsp;» un processus (<i>to sample</i> en anglais),

	  <br/>

	  et au lieu d'un «&nbsp;nombre pseudo-aléatoire&nbsp;» on parle d'«&nbsp;échantillon&nbsp;» (<i>a sample</i> en anglais).

	  <br/>

	  Quand on calcule la moyenne de plusieurs échantillons, on parle de moyenne <i>empirique</i>. Le mot «&nbsp;empirique&nbsp;» signifie ici que l'on à la moyenne de valeurs observées/mesurées, engendrées par un processus que l'on observe. Il s'oppose au mot «&nbsp;vrai&nbsp;» introduit plus haut qui signifie que l'on considère la valeur théorique, laquelle n'est pas observée, mais que l'on essaye d'estimer au mieux.

	  <br/>

	  La moyenne est une quantité que l'on peut calculer parmi des tas d'autres, probablement la plus connue. Il existe également la médiane, la variance, l'écart-type et bien d'autres. Chacune de ces quantités se nomme une <i>statistique</i>.

	  <br/>
	  
	  En termes de notation, on a l'habitude de noter la moyenne par la lettre grecque &mu; et la distinguer de <math xmlns="http://www.w3.org/1998/Math/MathML"> <mover> <mi>&#x3BC;</mi> <mo stretchy="false">^</mo> </mover> </math>&nbsp;: sans chapeau, c'est la <i>vraie</i> valeur, avec un chapeau c'est sa valeur empirique. Plus généralement, si on note une statistique avec une certaine lettre, on lui ajoute un chapeau quand on veut parler de sa valeur empirique&nbsp;; sans chapeau, c'est la vraie valeur de la statistique.

	</p>
	
	<h4>Activité 10</h4>
	<!-- loi des grds nb -->
	
	<p>

	  On considère <i>n</i> variables aléatoires indépendantes et identiquement distribuées (i.i.d.) notées X<sub>i</sub> de moyenne &mu;.
	  
	  <br/>
	  
	  La <i>loi des grands nombres</i> indique que la moyenne de ces X<sub>i</sub> tend vers <i>n</i> lorsque <i>n</i> tend vers l'infini.

	  <br/>
	  <br/>
	  
	  <b>Question 10&nbsp;:</b> générer 10000 nombres pseudo-aléatoires distribués selon une loi normale de moyenne nulle et d'écart-type 1. Calculer la moyenne des i premiers nombres pour i variant de 1 à 10000 en en faire un graphique.
	</p>
	
	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		En C, le fichier <kbd>barplot.c</kbd> définit la fonction <kbd>plot_series ()</kbd> qui prend cinq arguments&nbsp;:
	      </p>
	      <ul>
		<li>un tableau de tableaux de <kbd>double</kbd>s (un <kbd>double **</kbd>,</li>
		<li>un entier qui est le nombre de valeurs dans ce tableau,</li>
		<li>un entier qui est le nombre de tableau de tableaux&nbsp;: ici, c'est 1,</li>
		<li>un entier qui vaut 0,</li>
		<li>une chaîne de caractères qui contient le titre du graphique.</li>
	      </ul>
	      <p>
		On obtient cela&nbsp;:
		<br/>
		<br/>
		<img src="q10.png" width="500pt" />
		<br/>
		<br/>
		Qu'en pensez-vous&nbsp;?
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		En python, on utilise la fonction <kbd>plt.plot()</kbd>.
	      </p>
	    </td>
	  </tr>
	</table>

	<p>

	  <b>Question 10bis&nbsp;:</b> faire 10 fois la même chose qu'à la question 10 et afficher toutes les moyennes sur un même graphique.

	  <br/>
	  <br/>

	  J'obtiens ce qui suit&nbsp;:

	  <br/>

	  <img src="q11b.png" width="500pt" />
	  <img src="q11a.png" width="500pt" />

	  <br/>

	  La figure de droite étant juste un agrandissement sur les 400 premières itérations de la figure de gauche.
	  
	</p>
	
	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		En C vous utilisez la même fonction qu'à la question précédente mais cette fois-ci vous affichez plusieurs tableaux de <kbd>double</kbd>s.
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		En python, on utilise la fonction <kbd>plot()</kbd> de matplotlib.
	      </p>
	    </td>
	  </tr>
	</table>

	<p>

	  On voit que la moyenne empirique tend vers 0, qui est la moyenne de la distribution normale de moyenne nulle, la vraie moyenne.

	  <br/>
	  <br/>

	  La vitesse de convergence de la moyenne empirique vers la vraie moyenne est connue&nbsp;: l'écart entre les deux diminue comme

	  <math xmlns="http://www.w3.org/1998/Math/MathML">
	    <mn>1</mn>
	    <mrow data-mjx-texclass="ORD">
	      <mo>/</mo>
	    </mrow>
	    <msqrt>
	      <mn>t</mn>
	    </msqrt>
	  </math>.
	  
	  <br/>

	  On peut l'observer en ajoutant +/- cette valeur en pointillés sur les graphiques précédents&nbsp;:

	  <br/>
	  <br/>

	  <img src="q11b2.png" width="500pt" />
	  <img src="q11a2.png" width="500pt" />

	</p>
	
	<h4>Activité 11</h4>
	<!-- TCL -->
	
	<p>

	  <b>Question 11&nbsp;:</b> tirer 1000 nombres d'une distribution normale de moyenne nulle et d'écart-type 1. En calculer leur moyenne&nbsp;: on obtient une certaine valeur m<sub>1</sub>. Répéter cette expérience 300000 fois. Nous aurons 300000 valeurs m<sub>1</sub> à m<sub>300000</sub>. En faire un histogramme.

	  <br/>
	  <br/>

	  J'obtiens cela&nbsp;:

	  <br/>
	  <br/>
	  
	  <img src="q12n.png" width="500pt" />
	  
	  <br/>
	  <br/>

	  Cela illustre le <i>théorème central limite</i>&nbsp;: chaque m<sub>i</sub> calculée plus haut est une variable aléatoire.
	  À chaque itération, chacun des n (= 1000) nombres aléatoires a été tiré d'une distribution normale
	  <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi> </mrow></math> (&mu;, &sigma;) avec &mu;=0 et &sigma;=1.
	  Les valeurs de la variable aléatoire m (chacune est la moyenne de 1000 nombres pseudo-aléatoires) sont distribuées selon une loi normale
	  <math xmlns="http://www.w3.org/1998/Math/MathML">
	    <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi>(0,
	      <mn>&sigma;</mn>
	      <mo>=</mo>
	      <mn>1</mn>
	      <mrow data-mjx-texclass="ORD">
		<mo>/</mo>
	      </mrow>
	      <msqrt>
		<mn>n</mn>
	      </msqrt>
	    </math>), soit ici
	  <math xmlns="http://www.w3.org/1998/Math/MathML">
	    <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi> </mrow>(0,
	    <mn>1</mn>
	    <mrow data-mjx-texclass="ORD">
	      <mo>/</mo>
	    </mrow>
	    <msqrt>
	      <mn>1000</mn>
	    </msqrt>
	  </math>), soit environ  <math xmlns="http://www.w3.org/1998/Math/MathML">
	    <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi> </mrow>(0;&nbsp;
	    <mn>0,03</mn>
	  </math>).

	  <br/>
	  <br/>

	  Pour des nombres distribués uniformément dans [0, 1[, on obtient le même genre de graphique&nbsp;:

	  <br/>
	  <br/>
	  
	  <img src="q12u.png" width="500pt" />
	  
	</p>

	<h4>Activité 12</h4>
	<!-- écart-type -->
	
	<p>

	  Une autre caractéristique importante (qui saute aux yeux dans le cas d'une distribution normale) est l'étalement de la distribution des valeurs autour de la moyenne. Celle-ci est mesurée par l'<i>écart-type</i>.

	  <br/>

	  L'écart-type est la racine carrée de la <i>variance</i>. Celle-ci se définit très simplement comme la moyenne de l'écart au carré entre chaque échantillon et la moyenne empirique&nbsp;: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
	    <mo>var (</mo>
	    <msub>
	      <mi>x</mi>
	      <mi>i</mi>
	    </msub>
	    <mo>)=</mo>
	    <mfrac>
	      <mn>1</mn>
	      <mi>n</mi>
	    </mfrac>
	    <munderover>
	      <mo data-mjx-texclass="OP">&#x2211;</mo>
	      <mrow data-mjx-texclass="ORD">
		<mi>i</mi>
		<mo>=</mo>
		<mn>1</mn>
	      </mrow>
	      <mi>n</mi>
	    </munderover>
	    <mo stretchy="false">(</mo>
	    <msub>
	      <mi>x</mi>
	      <mi>i</mi>
	    </msub>
	    <mo>&#x2212;</mo>
	    <mrow data-mjx-texclass="ORD">
	      <mover>
		<mi>&#x3BC;</mi>
		<mo stretchy="false">^</mo>
	      </mover>
	    </mrow>
	    <msup>
	      <mo stretchy="false">)</mo>
	      <mn>2</mn>
	    </msup>
	  </math>

	  <br/>
	  <br/>

	  Pour ce qui est de l'écart-type, il en existe deux versions&nbsp;: une version biaisée et une version non biaisée. Si on prend la racine carrée de la variance, on obtient l'écart-type biaisé. Biaisé signifie qu'en moyenne, sa valeur diffère du vrai écart-type &sigma;. L'écart-type non biaisé (noté  <math xmlns="http://www.w3.org/1998/Math/MathML">
  <msub>
    <mrow data-mjx-texclass="ORD">
      <mover>
        <mi>&#x3C3;</mi>
        <mo stretchy="false">^</mo>
      </mover>
    </mrow>
    <mi>c</mi>
  </msub></math> avec un 'c' en indice pour indiquer qu'il est corrigé) est obtenu en divisant non pas par n mais par n-1&nbsp;: <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <msub>
    <mrow data-mjx-texclass="ORD">
      <mover>
        <mi>&#x3C3;</mi>
        <mo stretchy="false">^</mo>
      </mover>
    </mrow>
    <mi>c</mi>
  </msub>
  <mo>=</mo>
  <msqrt>
    <mfrac>
      <mn>1</mn>
      <mrow>
        <mi>n</mi>
        <mo>&#x2212;</mo>
        <mn>1</mn>
      </mrow>
    </mfrac>
    <munderover>
      <mo data-mjx-texclass="OP">&#x2211;</mo>
      <mrow data-mjx-texclass="ORD">
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>n</mi>
    </munderover>
    <mo stretchy="false">(</mo>
    <msub>
      <mi>x</mi>
      <mi>i</mi>
    </msub>
    <mo>&#x2212;</mo>
    <mrow data-mjx-texclass="ORD">
      <mover>
        <mi>&#x3BC;</mi>
        <mo stretchy="false">^</mo>
      </mover>
    </mrow>
    <msup>
      <mo stretchy="false">)</mo>
      <mn>2</mn>
    </msup>
  </msqrt>
</math>
	  
	</p>


	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		La fonction <kbd>gsl_stats_variance ()</kbd> de la GSL renvoie l'écart-type non biaisé.
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		Toujours prompt à ne pas bien faire les choses, la fonction <kbd>std()</kbd> de numpy renvoie l'écart-type biaisé par défaut. Si on ajoute le paramètre <kbd>ddof=1</kbd>, alors l'écart-type n'est pas biaisé.
	      </p>
	    </td>
	  </tr>
	</table>


	<p>

	  <b>Question 12&nbsp;:</b> écrire un programme qui génère 100000 nombres pseudo-aléatoires tirés selon une loi normale 
	  <math xmlns="http://www.w3.org/1998/Math/MathML">
	    <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi>(<mn>&mu;</mn>,<mn>&sigma;</mn>)</math> pour des valeurs de &mu; et &sigma; que vous fixez à votre goût.
	    Calculer les deux écarts-types et comparez-les entre-eux et avec la vraie valeur de l'écart-type.
	    
	</p>
	
	<h4>Activité 13</h4>
	
	<p>

	  Une autre manière de mesurer l'étalement d'une distribution de nombres consiste à déterminer la proportions d'échantillons qui sont à une certaine distance d de la moyenne &mu; <math xmlns="http://www.w3.org/1998/Math/MathML">  <mo stretchy="false">[</mo>  <mi>&#x3BC;</mi>  <mo>&#x2212;</mo>  <mi>d</mi>  <mo>,</mo>  <mi>&#x3BC;</mi>  <mo>+</mo>  <mi>d</mi>  <mo stretchy="false">]</mo> </math>.

	  <br/>
	  <br/>

	  <b>Question 13&nbsp;:</b> écrire une fonction qui prend en paramètre un tableau de nombres pseudo-aléatoires, une valeur de a et une valeur de b et qui renvoie la proportion d'éléments du tableau dont la valeur est comprise entre a et b.
	  
	  <br/>

	  <b>Question 13bis&nbsp;:</b> utilisez la fonction précédente pour déterminer la proportion de nombres qui se situent à 1 écart-type de la moyenne, puis 2 écarts-types de la moyenne, puis 3 écarts-types de la moyenne. Appliquez-la à 100000 nombres pseudo-aléatoires tirés selon une loi <math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi>(<mn>&mu;</mn>,<mn>&sigma;</mn>)</math>.
	    <br/>

	    La théorie nous dit que 68% des échantillons sont à moins d'un écart-type de la moyenne, 95% à moins de 2 écarts-types, 99,7% à moins de 3 écart-stypes. Retrouvez-vous ces proportions&nbsp;?

	</p>

	<h4>Activité 14</h4>
	<!-- quantiles -->
	
	<p>

	  Une dernière notion que nous définissons est celle de <i>quantile</i>&nbsp;: &alpha; étant un nombre réel quelconque, le quantile &alpha; d'un ensemble d'échantillons est la proportion de ces échantillons dont la valeur est &lt; &alpha;.

	  <br/>

	  <b>Question 14&nbsp;:</b> écrire une fonction qui prend en paramètre un tableau de nombres et la valeur de alpha et renvoie le quantile &alpha; de cet ensemble d'échantillons.

	  <br/>
	  
	  <b>Question 14bis&nbsp;:</b> utilisez la fonction précédente pour déterminer le quantile &alpha; d'un ensemble de 100000 nombres pseudo-aléatoires tirés selon une loi <math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow data-mjx-texclass="ORD"> <mi data-mjx-variant="-tex-calligraphic" mathvariant="script">N</mi>(<mn>0</mn>,<mn>1</mn>)</math> pour chaque valeur de &alpha; variant de -5 à 5 par pas de 0,1. Faites-une représentation graphique de ces quantiles.

	    <br/>
	  
	    <b>Question 14ter&nbsp;:</b> comment utilisez-vous cette fonction pour déterminer la valeur empirique de la médiane du tabeau de nombres&nbsp;?
	    
	  </p>
	  
	  <h2>Processus de Markov</h2>



	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		C is best
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		python is shit.
	      </p>
	    </td>
	  </tr>
	</table>
	
	</div>
	
</body>
</html>



    <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  C is best
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  python is shit.
	</p>
      </td>
    </tr>
  </table>

    	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		C is best
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		python is shit.
	      </p>
	    </td>
	  </tr>
	</table>

	<table>
	  <th>C</th><th>python</th>
	  <tr>
	    <td bgcolor="#bafcba" width="50%">
	      <p>
		C is best
	      </p>
	    </td><td bgcolor="#c0c0c0" width="50%">
	      <p>
		python is shit.
	      </p>
	    </td>
	  </tr>
	</table>

