<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr" lang="fr">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Processus aléatoires, statistiques et reproductibilité expérimentale</title>
  <link href="/home/ppreux/philippe-preux.github.io/css/ma.css" 
	rel="stylesheet" type="text/css" media="all" />
  <link rel="shortcut icon" type="image/x-icon" 
	href="/home/ppreux/philippe-preux.github.io/img/site.ico" />
  <style>
    div.c {
	background-color: #bafcba;
    }
    div.python {
	background-color: #c0c0c0;
    }
  </style>
</head>

<body>
<div class="tpR">

  <h1>Processus aléatoires, statistiques et reproductibilité expérimentale</h1>

  <p>

    Ce TP a pour objet de présenter un certain nombre de points liés à la maîtrise de la notion d'aléa dans les expériences informatiques.

    <br/>

    Dans les UEs de PDI et APR, nous étudions des algorithmes stochastiques, c'est-à-dire qu'<i>a priori</i>, ils donnent des résultats différents à chacune de leur exécution. Pour étudier le comportement de ces algorithmes, il faut tenir compte de cette variabilité et utiliser les outils adéquats pour cela. Outre la variabilité des résultats, un concept scientifique clé est la capacité à reproduire les résultats d'une expérience. L'objet de ce TP est d'étudier ces notions et d'indiquer comment les prendre en compte concrétement.

    <br/>
    <br/>

    Ce TP s'inspire fortement d'un TP réalisé ces dernières années en PDI qui est disponible <a href="https://fabienpesquerel.github.io/blog/2022/random-number-generation-101/">là</a>. Celui-ci est exprimé en utilisant le langage Python. Le TP présenté ici est réalisé en C ou en python, au choix, pour différentes raisons&nbsp;: 1) contrairement à ce que l'on peut croire, on n'est pas obligé de travailler en Python quand on travaille en apprentissage automatique et ce TP le démontre&nbsp;; 2) ce TP peut aussi très facilement être réalisé en R par exemple, ou C++ ou bien d'autres langages. <!--Et si vous préférez le faire en C++ ou R, allez-y&nbsp;! --> Je rappelle que <a href="https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf">le langage C est le langage le plus vert</a>, le moins consommateur en ressources, le moins pollueur (50x moins que python par exemple).

  </p>

  <h2>Génération de nombres pseudo-aléatoires</h2>

  <h3>Pré-requis</h3>

  <table>
    <th>C</th><th>python</th>
    <tr><td bgcolor="#c0c0c0" width="50%" >
	<div class="c">
	  On utilise la bibliothèque <kbd>gsl</kbd> (GNU Scientific Library) qui contient de multiples fonctions mathématiques. Elle est installée sur les ordinateurs en salle TP. Sur votre ordinateur personnel, il faut peut-être l'installer.

	  <br/>

	  On utilisera le compilateur <kbd>gcc</kbd> et on spécifiera les options <kbd>-lgsl -lgslcblas -lm</kbd> pour éditer les liens avec les bibliothèques nécessaires.
	</div>
      </td>
      <td bgcolor="#c0c0c0" width="50%" >
	<div class="python">
	  On utilise la bibliothèque <kbd>numpy</kbd> qui doit donc être installée.
	  </div>
      </td>
    </tr>
  </table>

  <h3>Génération de nombres pseudo-aléatoires</h3>
  
  <h4>Question 1</h4>
  
  <p>
    
    La notion de nombres (pseudo-)aléatoires est une notion complexe. La génération d'une séquence de nombres aléatoires par un algoithme est un problème aussi vieux que l'apparition des premiers ordinateurs&nbsp;; des progrès ont été faits et ils se poursuivent. La fonction de base consiste à générer un entier naturel dont la valeur est comprise entre 0 et 2<sup>N</sup>-1 où N est le nombre de bits composant les mots manipulés par le(s) microprocesseur(s) pendant un calcul. À chaque appel, cette fonction de base renvoit un nombre différent. On veut que cette séquence de nombres respectent certaines propriétés (par exemple, une distribution uniforme dans l'intervalle de valeurs, ou encore la non répétition de séquences) quel que soit le nombre d'appels à cette fonction, donc quelle que soit la longueur de la séquence de nombres pseudo-aléatoires générés. L'infini n'étant pas atteignable dans un programme d'ordinateur, on veut que ces propriétés soient respectées par des séquences aussi longues que possibles.

    <br/>
    <br/>

    <b>Question&nbsp;:</b> combien de séquences d'entiers différentes sont possibles avec un ordinateur travaillant sur N bits à la fois&nbsp;?

    <br/>
    <br/>

    Remarque&nbsp;: vous avez noté l'utilisation du mot «&nbsp;pseudo&nbsp;» avant le mot aléatoire. On veut ainsi distinguer un nombre aléatoire au sens mathématique du terme d'un nombre calculé par un algorithme pour donner l'impression que la séquence de nombres est aléatoire. Curieusement, l'algorithme qui calcule une telle séquence est <b>déterministe</b>&nbsp;: la séquence est construite à l'aide d'une (simple) équation de récurrence. Le premier terme (ou les premiers termes) de cette séquence est fourni par l'utilisateur et se nomme la <i>graine</i>.

    <br/>

    Quand on exécute un programme utilisant un générateur de nombres pseudo-aléatoires, il faut <b>impérativement</b> sauvegarder la valeur de la graine. C'est le seul moyen de ré-exécuter exactement de la même manière un programme. C'est une faute de ne pas sauvegarder cette valeur.
    
    <br/>
    <br/>

    Remarque&nbsp;: nous n'abordons pas ce point dans le cadre de ce TP ni de ce cours, mais la génération de nombres pseudo-aléatoires par un programme distribué ou simplement mutli-threadé complique les choses&nbsp;: les différentes séquences de nombres doivent êtres différentes mais elles doivent respecter des propriétés globales. 
    
    <br/>

    Autre remarque&nbsp;: d'un point de vue scientifique, on ne sait pas si l'aléatoire existe. Toute la physique, donc l'explication du monde, est déterministe jusqu'à la découverte de la physique quantique au début du XX<sup>è</sup> siècle. Celle-ci semble s'appuyer sur des processus intrinséquement aléatoires, mais c'est peut-être juste que nous l'avons pas encore bien comprise. La physique quantique a profondément perturbé les physiciens et plus généralement les scientifiques dans leur appréhension du monde.

    <br/>
    <br/>

    À partir d'un générateur d'entiers pseudo-aléatoires compris entre 0 et <kbd>MAX_INT</kbd>, on obtient facilement un nombre «&nbsp;réel&nbsp;» (flottant) compris dans [0, 1[ en divisant cet entier par <kbd>MAX_INT</kbd>. Comme il est très courant d'avoir besoin de générer des nombres dans cet intervalle, il y a généralement une fonction qui le fait directement, c'est-à-dire qui renvoit un nombre pseudo-aléatoire dans l'intervalle [0, 1[. 
    
  </p>
  
  <table>
    <th>C</th><th>python</th>
    <tr><td bgcolor="#bafcba" width="50%" >
	<p>
	  En C, on utilise typiquement une fonction qui génère un entier naturel pseudo-aléatoire compris entre 0 et <kbd>MAX_INT</kbd>. On obtient facilement un nombre flottant dans [0, 1[ en divisant cet entier par <kbd>MAX_INT</kbd>.

	  <br/>

	  On peut utiliser la fonction <kbd>random()</kbd> de la <kbd>libc</kbd> mais pour la suite du TP, il est avantageux d'utiliser la bibliothèque <kbd>gsl</kbd>. Cela va donner quelque chose comme cela&nbsp;

	</p>

	<ul>
	  <li>En début de programme, on inclut le fichier <kbd>gsl/gsl_rng.h</kbd>.</li>
	  <li>On définit une variable et on alloue une variable qui permettra de générer les nombres pseudo-aléatoires&nbsp;:
<pre>static gsl_rng *prng = NULL;
prng = gsl_rng_alloc (gsl_rng_mt19937);</pre>
	  <li>Et quand on veut générer un nombre pseudo-aléatoire, on fait simplement&nbsp;:
	    <ul>
	      <li>Pour un entier&nbsp;: <kbd>gsl_rng_get (prng)</kbd>.</li>
	      <li>Pour un flottant dans [0, 1[&nbsp;: <kbd>gsl_rng_uniform (prng)</kbd>.</li>
	    </ul>
	  </ul>
	<p>
	  Il existe de nombreuses manières de générer une séquence de nombres pseudo-aléatoires. Ici on utilise le <i>Mersenne Twister</i> en spécifiant <kbd>mt19937</kbd>. Cet algorithme est connu pour avoir de bonnes propriétés.
	</p>
      </td>
      <td bgcolor="#c0c0c0" width="50%" >
	<p>
	  En python, on utilise typiquement une fonction de la bibliothèque <kbd>numpy</kbd> qui renvoie un nombre flottant dans l'intervalle [0, 1[.
	</p>
<pre>import numpy as np
np.random.rand (1)</pre>
	<p>
          affiche un nombre pseudo-aléatoire compris entre 0 et 1 (0 inclus, 1 exclus).
	</p>
	<p>
	  En procédant ainsi, on utilise un algorithme qui se nomme PCG64 qui est plus récent que le Mersenne Twister et génère de meilleures séquences de nombres pseudo-aléatoires.
      </td>
    </tr>
  </table>

  <p>

    <b>Question 1&nbsp;:</b> écrire un programme qui affiche une suite de 10 nombres pseudo-aléatoires compris dans [0, 1[.
    
  </p>

  <h4>Question 2</h4>
  
  <p>

    Exécutez plusieurs fois le programme précédent et comparez les résultats&nbsp;: qu'observez-vous&nbsp;?

    <br/>

    En science, quand on effectue une expérience, il y a un principe fondamentale qui est celui de la reproductibilité&nbsp;: si je fais plusieurs fois la même expérience dans les mêmes conditions, le résultat doit toujours être le même.

    <br/>

    En informatique, dans certaines conditions, exécuter un programme est analogue à la réalisation d'une expérience. En appliquant le principe fondamental ci-dessus, on veut qu'exécuter un même programme plusieurs fois donne le même résultat. Et si on veut que programme donne des résultats différents à chaque exécution, on veut que cette variabilité soit contrôlée, c'est-à-dire qu'elle soit elle-même reproductible&nbsp;: on veut que l'aléatoire ce ne soit pas n'importe quoi, mais un aléatoire reproductible.

    <br/>

    La solution à ce problème est très simple. Elle consiste à initialiser la série de nombres pseudo-aléatoires avec un certain nombre qui se nomme une graine. Si on fournit une certaine graine à un certain générateur de nombres pseudo-aléatoires, il génère ensuite toujours la même séquence de nombres. Dans les exemples ci-dessous, on utilise la graine 123456. Utilisez celle que vous voulez.
    
  </p>

  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  En C, à la suite de ce qui a été expliqué plus haut, on fixe la graine par un appel à la fonction <kbd>gsl_rng_set (prng, 123456)</kbd>.
	  <br/>
	  Ensuite, la séquence de nombres qui sera générée lors des appels successifs aux fonctions vues plus haut sera toujours la même pour une graine donnée.
	</p>
      </td>
      <td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, on crée un générateur de nombres pseudo-aléatoires par <kbd>prng = np.random.default_rng (123456)</kbd>.
	  <br/>
	  Ensuite, on génère des nombres via cet objet&nbsp;: <kbd>prng.random(1)</kbd> où 1 indique la quantité de nombres pseudo-aléatoires à générer.
	</p>
      </td>
    </tr>
  </table>
  
  <p>

    <b>Question 2&nbsp;:</b> modifier votre programme en initialisant correctement la graine. Exécutez le plusieurs fois. Que constatez-vous&nbsp;?

    <br/>
    
    <b>Question 2bis&nbsp;:</b> comparer la séquence de nombres (une dizaine) par votre programme avec la graine n, n+1 et n-1. Que constatez-vous&nbsp;? Connaissez-vous un moyen de comparer ces séquences de nombres&nbsp;?
    
  </p>

  <h4>Question 3</h4>
  
  <p>

    
    
  </p>

  <h4>Question 4</h4>
  
  <p>

    
    
  </p>

  <h4>Question 5</h4>
  
  <p>

    Les nombres générés précédemment sont uniformément répartis dans l'intervalle [0, 1[. On va le vérifier en réalisant un histogramme.

    <br/>
    
    <b>Question 5&nbsp;:</b> générer 10.000 nombres pseudo-aléatoires compris dans [0, 1[ et en faire un histogramme.

  </p>
  
  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  En C, on va utiliser la bibliothèque PLplot qui permet de réaliser des graphiques. Le but de ce TP n'étant pas d'apprendre à utiliser PLplot, je mets à votre disposition deux fichiers que vous allez utilisez&nbsp;: <a href="./barplot.h"><kbd>barplot.h</kbd></a> et <a href="./barplot.c"><kbd>barplot.c</kbd></a>. Il faut inclure le premier dans votre programme et compiler votre programme avec le second. J'y ai défini quelques fonctions qui vont créer très facilement les graphiques nécessaires dans ce TP.
	  <br/>
	  <br/>
	  PLplot est installé sur les machines de la salle de TP. Pour compiler, il faut ajouter les arguments <kbd>-I./barplot.h -I/usr/include/plplot -lplplot</kbd> à la ligne de commande <kbd>gcc</kbd>.
	  <br/>
	  <br/>
	  Construction de l'histogramme blablabla. Puis&nbsp;:
	  </p>
	  <pre>barplot (h-> valeurs, h-> les_bords, nb_bins)</pre>
	  <p>
	  Et on obtient&nbsp;:
	  <br/>
	  <img src="q5.png" width="500pt" />
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, en plus de ce que l'on a vu pour générer des nombres pseudo-aléatoires, on va obtenir l'histogramme en utilisant la fonction <kbd>hist()</kbd> de la bibliothèque matplotlib. Ainsi, vous obtiendrez&nbsp;:
	  <br/>
	  <img src="q5fPCG64.png" width="500pt" />
	  <!--img src="https://fabienpesquerel.github.io/assets/img/posts/2022-10-16-random-number-generation-101/rng_post_answer5_1-1400.webp" width="500pt" /-->
	</p>
      </td>
    </tr>
  </table>

  <p>
    <b>Question 5bis&nbsp;:</b> comparer visuellement ces histogrammes&nbsp;; qu'en pensez-vous&nbsp;?
    <br/>
    <b>Question 5ter&nbsp;:</b> générer les histogrammes pour les graines n, n+1 et n-1. Que constatez-vous&nbsp;?
  </p>

  <h4>Question 6</h4>
  
  <p>

    Il est courant de vouloir générer des nombres pseudo-aléatoires dont la distribution n'est pas uniforme. Il existe en effet des tas de distributions de probabilité. On distingue les distributions discrètes des distributions continues. Par exemple, si on veut simuler le lancer d'un dé à 6 faces, on génère un nombre dans l'ensemble { 1, 2, 3, 4, 5, 6 }&nbsp;; si on veut simuler le lancer d'une pièce (pile ou face), on génère 0 ou 1, de manière équi-probable si la pièce est équilibrée, ou avec une probabilité <i>p</i> pour l'un et 1-<i>p</i> pour l'autre si la pièce est déséquilibrée. Dans le premier cas, c'est une distribution uniforme discrète&nbsp;; dans le troisième, c'est une loi de Bernoulli de paramètre <i>p</i>&nbsp;; le deuxième cas peut être vu soit comme une loi uniforme, soit comme une loi de Bernoulli avec <i>p</i>=1/2.

    <br/>
    <br/>

    Pour de très nombreuses lois de distribution de probabilités, il existe une fonction qui génère des nombres pseudo-aléatoires suivant cette loi. L'une des plus classiques est la loi normale (ou gaussienne, ou «&nbsp;en cloche&nbsp;».

    <br/>
    <br/>
    
    <b>Question 6&nbsp;:</b> générer 10.000 nombres pseudo-aléatoires distribués normalement (moyenne nulle, écart-type 1) et en faire un histogramme.

  </p>

  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  Avec la GSL, on génère un nombre pseudo-aléatoire selon une loi nrmale de moyenne nulle et d'écart-type <i>s</i> à l'aide de la fonction <kbd>gsl_ran_gaussian (prng, s)</kbd>. Pour accéder à cette fonction, il faut include le fichier <kbd>gsl/gsl_randist.h</kbd>.
	  <br/>
	  On obtient&nbsp;:
	  <br/>
	  <img src="q6.png" width="500pt" />
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  En python, on génère <i>n</i> nombres pseudo-aléatoires selon une loi nrmale de moyenne <i>m</i> et d'écart-type <i>s</i> à l'aide de la fonction <kbd>rng.normal (loc = m, scale = s, size = n)</kbd>.
	  <br/>
	  On obtient&nbsp;:
	  <br/>
	  <img src="q6fPCG64.png" width="500pt" />
	</p>
      </td>
    </tr>
  </table>

  <h4>Question 7</h4>
  
  <p>

    On va maintenant écrire notre propre générateur de nombres pseudo-aléatoires. Même s'il n'aura pas les bonnes propriétés des générateurs vus précédemment, il aura l'avantage d'être simple et de montrer comment on peut générer des nombres pseudo-aléatoires avec un algorithme déterministe.

    <br/>
    <br/>

    Ce générateur engendre des nombres compris dans ]0, 1[. Il s'appuie sur une équation de récurrence très simple&nbsp;: x<sub>n+1</sub> &leftarrow; m&nbsp;x<sub>n</sub> + c [q].

    <br/>

    Dans cette équation, m, c et q sont des paramètres&nbsp;:

    <br/>

    La notation [q] signifie «&nbsp;reste de la division de terme de gauche par q&nbsp;».

    <br/>

    Si a un moment x<inf>n</inf> est nul, il faut le remplacer par c.
    
    <br/>
    <br/>
    
    <b>Question 7&nbsp;:</b> implanter ce générateur de nombres pseudo-aléatoires. Générer 10.000 nombres et en faire un histogramme.
    
  </p>
  
  <h2>Quelques notions essentielles de statistiques</h2>

  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  C is best
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  python is shit.
	</p>
      </td>
    </tr>
  </table>
  
  <h2>Processus de Markov</h2>



  <table>
    <th>C</th><th>python</th>
    <tr>
      <td bgcolor="#bafcba" width="50%">
	<p>
	  C is best
	</p>
      </td><td bgcolor="#c0c0c0" width="50%">
	<p>
	  python is shit.
	</p>
      </td>
    </tr>
  </table>
  
</div>

</body>
</html>
